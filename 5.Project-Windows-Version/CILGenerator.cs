/*
Deep Lingo compiler - Common Intermediate Language (CIL) code generator.
2018, ITESM CEM.
* IRVIN EMMANUEL TRUJILLO D√çAZ A01370082
* LUIS FERNANDO ESPINOSA ELIZALDE A01375758

  This file is based on the Buttercup compiler -  Common Intermediate Language (CIL) code generator by Ariel Ortiz,
  Copyright (C) 2013.
  
Description of this class:Basically, this semantic analyzer looks 
for local variables in a AST in a specfic function and it stores it them in a set.

Note: We created the class "ContainerOfArrays"  and
each element will be an instance of that class so it can be compared in the set, 
this was done in orde to solve the problem of storing arrays in a set.

  This file is based on the Buttercup compiler - Semantic analyzer.
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Deeplingo {
    
    class CILGenerator {
        ContainerOfArrays container;
        bool flagAddpop = false;
        GlobalLocalTableStructure globalTableFuncs;
        GlobalSymbolVarTable globalTableVars;
        private String loopExit;
        int labelCounter = 0;
        int indexTypeAnchorTokenArray = 0;
        string labelIf = "";
        int inFunction = 0;
        
      
        //-----------------------------------------------------------
        //getter and setter
        public GlobalLocalTableStructure TableGlobalFunctions {
            get;
            private set;
        }
            
        //-----------------------------------------------------------
        //getter and setter
        public GlobalSymbolVarTable TableSymbolsGlobalVars {
            get;
            private set;
        }
        
        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }
        
        static readonly IDictionary<string, int> encodings = new Dictionary<string, int>() {
            { "\\n", 10},
            { "\\r", 13},
            { "\\t", 9},
            { "\\", 92},
            { "\\'", 39},
            { "\\\"", 34},
        };
        
        //-----------------------------------------------------------
        //Constructor.
        public CILGenerator(GlobalLocalTableStructure TableGlobalFunctions,GlobalSymbolVarTable TableSymbolsGlobalVars) {
            globalTableFuncs = TableGlobalFunctions;
            globalTableVars = TableSymbolsGlobalVars;
        }
        
        /*
        Note: Each visit is for each node indicated in the SpecificNode.cs
        */
        //YA
        //-----------------------------------------------------------
        public String Visit(Program node) {
            return "// Code generated by the deeplingo compiler.\n\n" 
                + ".assembly 'deeplingo' {}\n\n"
                + ".assembly extern 'deeplingolib' {}\n\n"
                + ".class public 'DeeplingoProgram' extends " 
                + "['mscorlib']'System'.'Object' {\n" 
                + Visit((dynamic) node[0]) //visit first children :v
                + "}";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(DefList node) { 
            return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        //-----------------------------------------------------------
        public String Visit(IdList node) {
            return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(VarDef node) { 
			if(inFunction>0){
			    return "\t\t.locals init (int32 '"+node.AnchorToken.Lexeme+"')\n";
			}
			else{
			    return "\t\t.field  public static  int32 '" + node.AnchorToken.Lexeme + "'\n";
			}
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(FunDef node) {
            inFunction++; //Dice que va a entrar a una funcion
            var fuctionName = node.AnchorToken.Lexeme;
            container = ContainerOfArrays.GetAndDeleteElementFromSet(globalTableFuncs.getTable(), fuctionName); //Recupera de la tabla de funciones la funcion deseada
            string result; 
			if(node.AnchorToken.Lexeme == "main"){ //Si es un main, debe tener un entrypoint
			    result = "\t\t.method public static int32 '"+node.AnchorToken.Lexeme+"'() {\n";
				result +=  "\t\t.entrypoint\n";
			}
			else{ //de lo contrario es una funcion normalita
			    string parameterLocal = "";
			    string parameters = "";
			    GlobalLocalTableStructure tabla = (GlobalLocalTableStructure)container.CustomArray[3]; //conviertes el objeto que representa la tabla de funciones locales en una tabla
			    foreach(var arr in tabla.getTable()){ //Recuperas el nombre de los parametros de tu tabla de la tabla
			        if((string)arr.CustomArray[1] == "parameter"){ //El elemento tiene que ser un parametro
			            parameterLocal += "\t\t.locals init (int32 '" + arr.CustomArray[0] + "')\n";
			            parameters += "int32,";
			        }
			    }
			    //Le da formatito al string del metodo
			    result = "\t\t.method public static int32 '"+node.AnchorToken.Lexeme+"'("
			    + parameters.Substring(0,parameters.Length-1)
			    + ") {\n"
			    + parameterLocal;
			}
			result += VisitChildren(node) + "\t\tldc.i4.0\n\t\tret\n" + "\t}\n"; //Visitar nodos hijos
			inFunction--; //Salir de estado funcion
			globalTableFuncs.Add(container); //Regresar container a la tabla
			return result;
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(ParamList node) {
            		return "";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(VarDefList node) {
            	return VisitChildren(node); 
            
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(StmtList node) {
            var temp = "";
			foreach(var n in node){ 
				if (n is FunCall){
				    ContainerOfArrays contenedor;
				    if((string)container.CustomArray[0]==n.AnchorToken.Lexeme){
				        contenedor = container;
				    }
				    else if(globalTableFuncs.Contains(n.AnchorToken.Lexeme)){
				        contenedor = ContainerOfArrays.GetAndDeleteElementFromSet(globalTableFuncs.getTable(), n.AnchorToken.Lexeme);
				        globalTableFuncs.Add(contenedor);
				        
				    }
				    else{
				        temp += Visit((dynamic) n);
				        continue;
				    }
				    if((string)contenedor.CustomArray[1]=="U"){ //userdefined..
				        var temp2 = " ";
    					var result = "";
    					int count = 0;
    					foreach(var element in n){
    						foreach(var x in element){
    						    count++;
    						}
    					}
    					if(count>0 && n[0] is ExprList){
    					    foreach(var element in n[0]){
    					        temp2 += "int32,";
        						result += Visit((dynamic) element);
    					    }
    					}
    					else{
    					    foreach(var element in n){
    					        temp2 += "int32,";
        						result += Visit((dynamic) element);
    					    }
    					}
    					temp += result
            				+ "\t\tcall int32 class 'DeeplingoProgram'::'" + n.AnchorToken.Lexeme + "'("+ temp2.Substring(0, temp2.Length-1)+")\n" 
            				+ "\t\tpop\n";
				    }
					else{
					    temp += Visit((dynamic) n);
					}
				}
				else{
					temp += Visit((dynamic) n);	
				}
			}
			return temp;
            
        }
        
        //YA
        //-----------------------------------------------------------
       	public string Visit (FunCall node){
			switch(node.AnchorToken.Lexeme){
				case "printi":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Printi'(int32)\n"
				    + "\t\tpop\n";
				case "printc":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Printc'(int32)\n"
				    + "\t\tpop\n";
				case "prints":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Prints'(int32)\n"
					+ "\t\tpop\n";
				case "println":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Println'()\n"
				    + "\t\tpop\n";
				case "readi":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Readi'()\n";
				case "reads":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Reads'()\n";
				case "new":
					return VisitChildren(node) 
					+"\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'New'(int32)\n";
				case "size":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Size'(int32)\n";
				case "add":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Add'(int32,int32)\n"
					+ "\t\tpop\n";
				case "get":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Get'(int32,int32)\n";
				case "set":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Set'(int32,int32,int32)\n"
					+ "\t\tpop\n";	
				case "pow":
					return VisitChildren(node) 
					+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Pow'(int32,int32)\n";	
				default:
					var temp2 = "";
					if(flagAddpop){
						temp2 = "\t\tpop\n";
						flagAddpop  = false;
					}
					
					var temp = " ";
					var result = "";
					int count = 0;
					foreach(var n in node){
						foreach(var element in n){
						    count++;
						}
					}
					if(count>0  && node[0] is ExprList){
					    foreach(var n in node[0]){
					        temp2 += "int32,";
    						result += Visit((dynamic) n);
					    }
					}
					else{
					    foreach(var n in node){
					        temp2 += "int32,";
    						result += Visit((dynamic) n);
					    }
					}
					
					var tempResult = result
					+ "\t\tcall int32 class 'DeeplingoProgram'::'" + node.AnchorToken.Lexeme + "'("+ temp2.Substring(0, temp2.Length-1)+")\n" 
					+ temp;
					return tempResult;
			}
		}
        
        //YA
        //-----------------------------------------------------------
        public String Visit(ExprList node) {
            return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Or node) {
            var result = "";
			var truecondition = GenerateLabel();
			var endcondition = GenerateLabel();
			if(node.AnchorToken.Category == TokenCategory.OR){
				foreach(var n in node){
					result += Visit((dynamic) n)
					+ "\t\tldc.i4.0\n"
					+ "\t\tbne.un '"+truecondition+"'\n";
				}
				return result
				+ "\t\tldc.i4.0\n"
				+ "\t\tbr "+endcondition+"\n"
				+ "'"+truecondition + "':\n"
				+ "\t\tldc.i4 42\n"
				+ "'"+endcondition + "':\n";
			}
			return node.ToString() + "\n" +VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(And node) {
            var result = "";
			var lbl = GenerateLabel();
			var lbl2 = GenerateLabel();
			if(node.AnchorToken.Category == TokenCategory.AND){
				foreach(var n in node){
					result += 
					Visit((dynamic) n)
					+ "\t\tldc.i4 42\n"
					+ "\t\tbne.un '"+lbl+"'\n"; 
				}
				return result
				+ "\t\tldc.i4 42\n"
				+ "\t\tbr "+lbl2 +"\n"
				+ "'" + lbl + "':\n"
				+ "\t\tldc.i4.0\n"
				+ "'" + lbl2 + "':\n";
					
			}
			return node.ToString() + "\n" +VisitChildren(node);
                
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(OpComp node) {
            var label = GenerateLabel();
            if(node.AnchorToken.Category == TokenCategory.EQUAL){
                return "\t\tldc.i4.0\n"
                + VisitChildren(node)
                +  "\t\tbne.un '"+label+"'\n"
                +  "\t\tpop\n"
                +  "\t\tldc.i4 42\n"
                + "'" + label + "':\n"; //no se le pone tabulacion nunca al ultimo label, regla :v
            }
            if(node.AnchorToken.Category == TokenCategory.NOT_EQUAL){
                return "\t\tldc.i4 42\n"
                    + VisitChildren(node)
                    +  "\t\tbne.un '"+label+"'\n"
                    +  "\t\tpop\n"
                    +  "\t\tldc.i4.0\n"
                    + "'" + label + "':\n"; //no se le pone tabulacion nunca al ultimo label, regla :v
            }
            return "\t\t"+node.ToString() + "\n" +VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(OpRel node) {
            var label = GenerateLabel();
            if(node.AnchorToken.Category == TokenCategory.GREATER){
            return "\t\tldc.i4.0\n"
                + VisitChildren(node)
                +"\t\tble '" + label + "'\n"
                +"\t\tpop\n"
                +"\t\tldc.i4 42\n"
                + "'" + label + "':\n"; //no se le pone tabulacion nunca al ultimo label, regla :v
            }
            if(node.AnchorToken.Category == TokenCategory.LESS_EQUAL){
                return "\t\tldc.i4 42\n"
                    + VisitChildren(node)
                    +"\t\tble '"+label+"'\n"
                    +"\t\tpop\n"
                    +"\t\tldc.i4.0\n"
                    + "'" + label + "':\n"; //no se le pone tabulacion nunca al ultimo label, regla :v
            }
            if(node.AnchorToken.Category == TokenCategory.GREATER_EQUAL){
    		    return"\t\tldc.i4 42\n"
    				+ VisitChildren(node)
    				+ "\t\tbge '"+label+"'\n"
    				+ "\t\tpop\n"
    				+ "\t\tldc.i4.0\n"
    				+ "'" + label + "':\n";	
    		}
    		if(node.AnchorToken.Category == TokenCategory.LESS){
    			return "\t\tldc.i4.0\n"
    				+ VisitChildren(node)
    				+ "\t\tbge '"+label+"'\n"
    				+ "\t\tpop\n"
    				+ "\t\tldc.i4 42\n"
    				+ "'" +  label + "':\n";	
    		}
            return "\t\t"+node.ToString() + "\n" +VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(OpAdd node) {
              if(node.AnchorToken.Category == TokenCategory.PLUS){
		        return VisitChildren(node) + "\t\tadd.ovf\n";
		    }
		    else if(node.AnchorToken.Category == TokenCategory.NEG){
		        return VisitChildren(node) + "\t\tsub\n";
		    }
			return "\t\t"+node.ToString() + "\n" +VisitChildren(node);
		}
            
        
        //YA
        //-----------------------------------------------------------
        public String Visit(OpMul node) {
            	switch(node.AnchorToken.Category){
    				case TokenCategory.REMAINDER:
    					return VisitChildren(node) + 
    					"\t\trem\n";
    				case TokenCategory.MUL:
    					return VisitChildren(node) + 
    					"\t\tmul.ovf\n";
    				case TokenCategory.DIV:
    					return VisitChildren(node) + 
    					"\t\tdiv\n";
    				default:
    					return null;
			}
            
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(OpUnary node) {
            if(node.AnchorToken.Lexeme.Equals("!")){
				var lbl = GenerateLabel();
				return "\t\tldc.i4.0\n"
					+ VisitChildren(node)
					+ "\t\tldc.i4 42\n"
					+ "\t\tbeq '"+lbl+"'\n"
					+ "\t\tpop\n"
					+ "\t\tldc.i4 42\n"
					+ "'" +  lbl+"':\n";
			}
			if(node.AnchorToken.Lexeme.Equals("-")){
				return "\t\tldc.i4.0"+
					VisitChildren(node) 
					+ "\t\tsub";
			}
			if(node.AnchorToken.Lexeme.Equals("+")){
				return VisitChildren(node);
			}
            return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Identifier node) {
            var identifier = node.AnchorToken.Lexeme; //Toma el nombre del identificador
            GlobalLocalTableStructure tabla = (GlobalLocalTableStructure)container.CustomArray[3]; //Crea una tabla a partir del objeto que representa la tabla de variables locales de la funcion
            string result;
            if(tabla.Contains(identifier)){ //Si el identificador esta dentro de la tabla de funciones locales
                ContainerOfArrays contenedor = ContainerOfArrays.GetAndDeleteElementFromSet(tabla.getTable(), identifier); //saca este elemento
                if((string)contenedor.CustomArray[1]=="parameter"){ //Es un parametro
                    int index = Int32.Parse((string)contenedor.CustomArray[2]);
                    result = "\t\tldarg." + index + "\n";
                    tabla.Add(contenedor);
                    return result;   
                }
                else{ //es variable local del metodo
                    tabla.Add(contenedor);
                    return "\t\tldloc '" + identifier + "'\n";
                }
            }
            else{ //Debe esta en la tabla global
                return ""
                + "\t\tldsfld int32 'DeeplingoProgram'::'" + identifier + "'\n";
            }
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Array node) {
			var sbNodes = new StringBuilder();
			foreach (var n in node[0]) {
			    sbNodes.Append("\t\tdup\n");
			    sbNodes.Append(Visit((dynamic) n));
			    sbNodes.Append("\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Add'(int32,int32)\n");
			    sbNodes.Append("\t\tpop\n");
            }
            return "\t\tldc.i4.0\n"
            + "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'New'(int32)\n"
            + sbNodes.ToString();
		}
            
        
        //YA
        //-----------------------------------------------------------
        public String Visit(StringLiteral node) {
            var val = node.AnchorToken.Lexeme;
			var size = val.Length;
			string temp = "";
			for(var i = 1;i<size-1;i++){
				var toadd = (int)val[i];
				if(i+1<size-1 && encodings.ContainsKey(val.Substring(i,2))){
                    toadd = encodings[val.Substring(i,2)];
					i += 1;
				}
				else if(i+7<size-1 && val.Substring(i,2) == @"\u"){
					toadd = getSpecialCharCodePoint(val.Substring(i+2,6));
					i += 7;
				}
				temp += "\t\tdup\n"
				+ "\t\tldc.i4 "+ toadd + "\n"
				+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Add'(int32,int32)\n"
				+ "\t\tpop\n";	
			}
			return "\t\tldc.i4.0\n"
			+ "\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'New'(int32)\n"
			+ temp;
            //return "\t\tldstr "+ node.AnchorToken.Lexeme +"\n";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(CharLiteral node) {
            var s = node.AnchorToken.Lexeme;
			if(s.Length > 3){
				if(encodings.ContainsKey(s.Substring(1,2))){
					return "\t\tldc.i4.s " + encodings[s.Substring(1,2)] +"\n"
					+ VisitChildren(node);	
				}
				else if(s.Substring(1,2) == @"\u"){
					var codePoint = getSpecialCharCodePoint(s.Substring(3,6));
		                  if (codePoint <= 8) {
				            return "\t\tldc.i4." + codePoint + "\n";	
				        }
				        else if (codePoint <= 127) {
				            return "\t\tldc.i4.s " + codePoint + "\n";	
				        } 
				        else {
				            return "\t\tldc.i4 " + codePoint + "\n";	
				        } 
		                //Console.WriteLine(hexCode+" = "+codePoint);
				}
			}
			return "\t\tldc.i4.s " + (int)node.AnchorToken.Lexeme[1]  + "\n";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(IntLiteral node) {
            var intValue = Convert.ToInt32(node.AnchorToken.Lexeme);
            if (intValue <= 8) {
                return "\t\tldc.i4." + intValue + "\n";
            } else if (intValue <= 127) {
                return "\t\tldc.i4.s " + intValue + "\n";
            } else {
                return "\t\tldc.i4 " + intValue + "\n";
            }
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(If node) {
            var label = GenerateLabel();
			var oldfinalLabel = labelIf;
			labelIf = GenerateLabel();
			var result = Visit((dynamic) node[0])//STMT
    			+ "\t\tldc.i4 42\n"
    			+ "\t\tbne.un '"+label+"'\n"//SI ES FALSE VETE AL FINAL
    			+ Visit((dynamic) node[1])//IF BODY
    			+ "\t\tbr "+labelIf+"\n"
    			+ "'" +  label + "':\n"//SE SALTA EL BODY SI ES FALSE
    			+ Visit((dynamic) node[2])//ELSE IFS
    			+ Visit((dynamic) node[3])
    			+ "'" +  labelIf + "':\n";
			labelIf = oldfinalLabel;
			return result;
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(ElseIfList node) {
            	return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(ElseIf node) {
            	var label = GenerateLabel();
            	return 
            	Visit((dynamic) node[0])
            	+ "\t\tldc.i4 42\n"
            	+ "\t\tbne.un " + label + "\n"
            	+ Visit((dynamic) node[1])
            	+ "'" +  label + "':\n";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Else node) {
            	return VisitChildren(node);
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Loop node) {
            var label1 = GenerateLabel();
            var oldLoop = loopExit;
            loopExit = GenerateLabel();
            var result = "'" + label1 + "':\n"
                + Visit((dynamic) node[0])
                + "\t\tbr " + label1 + "\n"
                + "'" +  loopExit + "':\n";
            loopExit = oldLoop;
            return result;
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Break node) {
            return "\t\tbr "+ loopExit + "\n";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Return node) {
            indexTypeAnchorTokenArray++;
            return VisitChildren(node)
                + "\t\tret\n";
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(StmtEmpty node) {
            	return ""; 
            
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Assign node) {
            var identifier = node.AnchorToken.Lexeme; //Toma el nombre del identificador
            GlobalLocalTableStructure tabla = (GlobalLocalTableStructure)container.CustomArray[3]; //Crea una tabla a partir del objeto que representa la tabla de variables locales de la funcion
            string result;
            if(tabla.Contains(identifier)){ //Si el identificador esta dentro de la tabla de funciones locales
                ContainerOfArrays contenedor = ContainerOfArrays.GetAndDeleteElementFromSet(tabla.getTable(), identifier); //saca este elemento
                if((string)contenedor.CustomArray[1]=="parameter"){ //Es un parametro
                    tabla.Add(contenedor);
                    int index = Int32.Parse((string)contenedor.CustomArray[2]);
                    result = Visit((dynamic) node[0])
                    + "\t\tstarg.s " + index + "\n";
                    return result;   
                }
                else{ //es variable local del metodo
                    tabla.Add(contenedor);
                    result = Visit((dynamic) node[0])
                    + "\t\tstloc '" + identifier + "'\n";
                    return result;
                }
            }
            else{ //Debe esta en la tabla global
                return ""
                + Visit((dynamic) node[0]) 
                + "\t\tstsfld int32 'DeeplingoProgram'::'" + identifier + "'\n";
            }
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Increment node) {
            return "\t\tldloc '"+node[0].AnchorToken.Lexeme+"'\n" + 
		    "\t\tldc.i4.1\n" +
			"\t\tadd\n"+
			"\t\tstloc '"+node[0].AnchorToken.Lexeme+"'\n";
            
        }
        
        //YA
        //-----------------------------------------------------------
        public String Visit(Decrement node) {
            return "\t\tldloc '"+node[0].AnchorToken.Lexeme+"'\n" + 
		    "\t\tldc.i4.1\n" +
			"\t\tsub\n"+
			"\t\tstloc '"+node[0].AnchorToken.Lexeme+"'\n";
        }
        
        //-----------------------------------------------------------
          string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }
        
        int getSpecialCharCodePoint(string hexCode){
            int codePoint = 0;
            try{
                codePoint = (int)Convert.ToInt64(hexCode, 16);
            }
            catch(Exception e){
                Console.WriteLine("getSpecialCharCodePoint error:"+e);
            }
            return codePoint;
        }
    }
}